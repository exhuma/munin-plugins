#!/usr/bin/env python
"""
Screen Scrape the FritzBox web interface for CRC and FEC errors on both the
"Fritz" (client) and "DSL" (provider?) end.

Usage
-----

Link into your munin-plugins folder::

    cd /etc/munin/plugins
    ln -s /opt/munin-plugins/fritz-7390-errors

And create a config file ``/etc/munin/plugin-conf.d/fritz-7390-errors`` with
the following contents (replacing the IP with that of your fritz of course)::

    [fritz-7390-errors]
       env.URL http://192.168.0.1

Known issues
------------

* Currently only supports interfaces without HTTP AUTH!
"""
#%# family=auto
#%# capabilities=autoconf

from __future__ import print_function
from collections import namedtuple
from textwrap import dedent
from argparse import ArgumentParser
from os import getenv
from urllib2 import urlopen, URLError
import sys
import re


Errors = namedtuple(
    'Errors',
    'fec_fritz_per_min, crc_fritz_per_min, fec_dsl_per_min, crc_dsl_per_min')
STAT_PATTERN = re.compile(r'^\["(.*?)"\] = "(.*?)",?$')


class FritzClient(object):
    """
    HTTP client to the fritz box.
    """

    def __init__(self, config):
        """
        Initialises the object
        """
        self.config = config

    def has_access(self):
        """
        Determines if the access to the FritzBox works. Returns a tuple
        (boolean, reason)
        """
        try:
            response = urlopen(self.config.url, timeout=2)
            print(response.read())
            return True, "Successfully connected"
        except URLError as exc:
            return False, exc.reason

    def get_errors(self):
        """
        Returns FEC and CRC errors
        """
        response = urlopen('{}/internet/dsl_stats_tab.lua'.format(
            self.config.url), timeout=2)
        data = response.read()
        values = {}
        for line in data.splitlines():
            match = STAT_PATTERN.match(line.strip())
            if match:
                var, value = match.groups()
                values[var] = value
        return Errors(
            float(values['sar:status/ds_fec_minute']),
            float(values['sar:status/ds_crc_minute']),
            float(values['sar:status/us_fec_minute']),
            float(values['sar:status/us_crc_minute']))


class Config(object):

    def __init__(self, url, username, password):
        self.url = url
        self.username = username
        self.password = password

    def __repr__(self):
        return u'<Config url={!r}, username={!r}, password={!r}>'.format(
            self.url,
            self.username,
            '****' if self.password else None)


class Application(object):
    """
    The main application code.
    """

    def __init__(self, args, config):
        self.args = args
        self.config = config
        self.client = FritzClient(self.config)

    def execute(self):
        """
        Executes one command
        """
        cmdfunc = 'do_{}'.format(self.args.command)
        if hasattr(self, cmdfunc):
            getattr(self, cmdfunc)()
        else:
            print(u'Unknown command: {!r}'.format(self.args.command),
                  file=sys.stderr)

    def do_config(self):
        """
        Implementation for command "config"
        """
        print(dedent(
            """\
            graph_title FritzBox errors
            graph_vlabel error count
            graph_scale no
            graph_category Internet
            graph_args --base 1000 --lower-limit 0
            graph_info Error counters for the fritz box.
            fec_fritz_per_min.info Fritz recoverable errors per minute (FEC)
            fec_fritz_per_min.label fritz_fec
            fec_fritz_per_min.draw AREA
            crc_fritz_per_min.info Fritz unrecoverable errors per minute (CRC)
            crc_fritz_per_min.label fritz_crc
            crc_fritz_per_min.draw STACK
            fec_dsl_per_min.info DSL recoverable errors per minute (FEC)
            fec_dsl_per_min.label dsl_fec
            fec_dsl_per_min.draw AREA
            crc_dsl_per_min.info DSL unrecoverable errors per minute (CRC)
            crc_dsl_per_min.label dsl_crc
            crc_dsl_per_min.draw STACK"""))

    def do_autoconf(self):
        """
        Implementation for command "autoconf"
        """
        may_access, reason = self.client.has_access()
        if may_access:
            print("yes")
        else:
            print(u"no (unable to access the FritzBox via {!r}): {}".format(
                self.config, reason))

    def do_fetch(self):
        """
        Implementation for command "fetch"
        """
        errors = self.client.get_errors()
        print(dedent(
            u"""\
            fec_fritz_per_min.value -{0.fec_fritz_per_min!s}
            crc_fritz_per_min.value -{0.crc_fritz_per_min!s}
            fec_dsl_per_min.value {0.fec_dsl_per_min!s}
            crc_dsl_per_min.value {0.crc_dsl_per_min!s}""".format(errors)))


def parse_args():
    """
    Parses CLI arguments and returns an object with the following attributes:

    * ``command`` - The command to the plugin (config,)
    """

    parser = ArgumentParser(description=dedent(
        """\
        screen-scrapes the FritzBox 7390 web-page to retrieve FEC and CRC
        errors. Unfortunately, the box does not support SNMP for more
        efficient polling."""))

    parser.add_argument('command', nargs='?', help=u'Plugin command',
                        default='fetch')
    return parser.parse_args()


def config():
    """
    Returns an :py:class:`.Config` instance.
    """

    return Config(
        getenv('URL'),
        getenv('USERNAME'),
        getenv('PASSWORD'))


def main():
    """
    Main entry point of the app.
    """
    args = parse_args()
    cfg = config()
    app = Application(args, cfg)
    app.execute()


if __name__ == '__main__':
    main()

#!/usr/bin/env python

from __future__ import print_function
from collections import namedtuple
from os import getenv
from psycopg2 import connect  # TODO <- munin autoconfig
from textwrap import dedent
import argparse
import re


GRAPH_NAME = 'connections'
INVALID_CHARS = re.compile(r'[^a-zA-Z0-9_]')
ConnectionCounter = namedtuple(
    'ConnectionCounter',
    'username idle idle_tx unknown query_running waiting')


def construct_dsn(dbname, user, password='', host='', port=0):
    elements = [
        'dbname=%s' % dbname,
        'user=%s' % user
    ]
    if password:
        elements.append('password=%s' % password)
    if host:
        elements.append('host=%s' % host)
    if port:
        elements.append('port=%d' % port)

    return ' '.join(elements)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('action', nargs='?',
                        help='The munin action to perform',
                        default='fetch')
    return parser.parse_args()


class PostgresPlugin(object):

    def __init__(self, connection):
        self.connection = connection


class Connections(PostgresPlugin):

    def all_connections(self):
        # Fetch the current username of the connection
        cursor = self.connection.cursor()
        cursor.execute('SELECT CURRENT_USER')
        whoami = cursor.fetchone()[0]
        cursor.close()

        query = dedent(
            '''\
            WITH users AS (SELECT usename FROM pg_user),
            conntype AS (SELECT u.usename, act.waiting,
                current_query
                FROM users u
                LEFT JOIN pg_stat_activity act USING (usename))
            SELECT
                usename,
                COUNT(CASE WHEN current_query='<IDLE>'
                    THEN 1 END) AS idle,
                COUNT(CASE WHEN current_query='<IDLE> in transaction'
                    THEN 1 END) AS idle_tx,
                COUNT(CASE WHEN current_query='<insufficient privilege>'
                    THEN 1 END) AS unknown,
                COUNT(CASE WHEN current_query NOT IN (
                    '<IDLE>',
                    '<IDLE> in transaction',
                    '<insufficient privilege>')
                    THEN 1 END) AS query_running,
                COUNT(CASE WHEN waiting THEN 1 END) AS waiting
            FROM conntype
            GROUP BY usename
            ORDER BY usename;''')
        cursor = self.connection.cursor()
        cursor.execute(query)
        output = []
        for username, idle, idle_tx, unknown, query_running, waiting in cursor:
            if username == whoami:  # Subtract our own active query
                query_running = query_running - 1
            output.append(ConnectionCounter(username, idle, idle_tx, unknown,
                                            query_running, waiting))
        cursor.close()
        return output

    def fetch(self):
        conns = self.all_connections()
        sums = {
            'idle': sum([conn.idle for conn in conns]),
            'idle_transaction': sum([conn.idle_tx for conn in conns]),
            'unknown': sum([conn.unknown for conn in conns]),
            'query_running': sum([conn.query_running for conn in conns]),
            'waiting': sum([conn.waiting for conn in conns]),
        }

        print('multigraph %s' % GRAPH_NAME)
        print('idle.value %d' % sums['idle'])
        print('idle_transaction.value %d' % sums['idle_transaction'])
        print('unknown.value %d' % sums['unknown'])
        print('query_running.value %d' % sums['query_running'])
        print('waiting.value %d' % sums['waiting'])

        # print values for the each subgraph
        for subgraph in conns:
            print('multigraph %s.%s' % (
                GRAPH_NAME,
                INVALID_CHARS.sub('_', subgraph.username)))
            print('idle.value %d' % subgraph.idle)
            print('idle_transaction.value %d' % subgraph.idle_tx)
            print('unknown.value %d' % subgraph.unknown)
            print('query_running.value %d' % subgraph.query_running)
            print('waiting.value %d' % subgraph.waiting)

    def config(self):
        # We want the main and subgraph to use the same config. So we store it
        # as a variable.
        common_config_block = dedent(
            '''\
            graph_category postgresql_multi
            graph_args --base 1000
            graph_vlabel connections
            graph_order waiting query_running idle idle_transaction unknown
            graph_printf %3.0lf
            waiting.label Waiting for lock
            waiting.draw AREA
            query_running.label Active query
            query_running.draw STACK
            idle.label Idle connections
            idle.draw STACK
            idle_transaction.label Idle transaction
            idle_transaction.draw STACK
            unknown.label unknown
            unknown.draw STACK
            ''')

        conns = self.all_connections()

        print('multigraph %s' % GRAPH_NAME)
        print('graph_title Global PostgreSQL Connections')
        print('graph_info Shows an overview of connections and their type on '
              'the PostgreSQL cluster.')

        print(common_config_block)
        for subgraph in conns:
            clean_username = INVALID_CHARS.sub('_', subgraph.username)
            print('multigraph %s.%s' % (GRAPH_NAME, clean_username))
            print('graph_title PostgreSQL Connections for %s' %
                  subgraph.username)
            print(common_config_block)


def main(action):
    dbname = getenv('PG_DBNAME', 'template1')
    user = getenv('PG_USER', 'postgres')
    password = getenv('PG_PASSWORD', '')
    host = getenv('PG_HOST', '')
    port = int(getenv('PG_PORT', 0))

    connection = connect(construct_dsn(
        dbname,
        user,
        password,
        host,
        port))

    try:
        for cls in (Connections, ):
            instance = cls(connection)
            if action == 'config':
                instance.config()
            else:
                instance.fetch()
    finally:
        connection.close()


if __name__ == '__main__':
    args = parse_args()
    main(args.action)
